var J=Object.defineProperty;var M=Object.getOwnPropertySymbols;var L=Object.prototype.hasOwnProperty,P=Object.prototype.propertyIsEnumerable;var S=(n,r,t)=>r in n?J(n,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[r]=t,N=(n,r)=>{for(var t in r||(r={}))L.call(r,t)&&S(n,t,r[t]);if(M)for(var t of M(r))P.call(r,t)&&S(n,t,r[t]);return n};var A=(n,r,t)=>(S(n,typeof r!="symbol"?r+"":r,t),t),z=(n,r,t)=>{if(!r.has(n))throw TypeError("Cannot "+t)};var p=(n,r,t)=>(z(n,r,"read from private field"),t?t.call(n):r.get(n)),O=(n,r,t)=>{if(r.has(n))throw TypeError("Cannot add the same private member more than once");r instanceof WeakSet?r.add(n):r.set(n,t)},x=(n,r,t,e)=>(z(n,r,"write to private field"),e?e.call(n,t):r.set(n,t),t);var R=new Set(["string","number","boolean","null","undefined","symbol"]),y=n=>isNaN(n)&&typeof n=="number",E=n=>typeof n=="object"&&n!==null&&Array.isArray(n)===!1,d=n=>R.has(typeof n),Q=JSON.stringify,W=JSON.parse;var g=(n,r)=>{if(n.length!==r.length)throw new Error("Arrays must be of the same lengths in a logical operation")};var f=()=>{throw new Error("iteratee has to be either of type 'string' or 'function'")};var _=class extends Array{constructor(r){super(0);this.push(...r),Object.freeze(this)}static get[Symbol.species](){return Array}},j=n=>new _(n);var v=n=>{if(n.length<=1)return n;let r=[],t=[],e=[],s=n.pop(),i=n.length;for(let h=0;h<i;h++)n[h]<=s?r.push(n[h]):t.push(n[h]);return e.concat(v(r),s,v(t))},V=(n,r)=>{let t=[];for(;n.length&&r.length;)t.push(n[0]>r[0]?r.shift():n.shift());for(;n.length;)t.push(n.shift());for(;r.length;)t.push(r.shift());return t},b=n=>{if(n.length<2)return n;let r=Math.floor(n.length/2),t=n.slice(0,r),e=n.slice(r,n.length),s=b(t),i=b(e);return V(s,i)},q=n=>{for(let r=1;r<n.length;r++){let t=r-1,e=n[r];for(;t>=0&&n[t]>e;)n[t+1]=n[t],t--;n[t+1]=e}return n},T=n=>{let r,t=n.length-1,e=n;do{r=!1;for(let s=0;s<t;s++)if(e[s]<e[s+1]){let i=e[s];e[s]=e[s+1],e[s+1]=i,r=!0}t--}while(r);return e},D=n=>{let r=s=>{let i=0;for(let h of s)i=i<h.toString().length?h.toString().length:i;return i},t=(s,i)=>Math.floor(s/Math.pow(10,i))%10,e=r(n);for(let s=0;s<e;s++){let i=Array.from({length:10},()=>[]);for(let h=0;h<n.length;h++)i[t(n[h],s)].push(n[h]);n=[].concat(...i)}return n},F=n=>{let r,t=(i,h)=>{let a=2*h+1,o=2*h+2,l=h;a<r&&i[a]>i[l]&&(l=a),o<r&&i[o]>i[l]&&(l=o),l!=h&&(e(i,h,l),t(i,l))},e=(i,h,a)=>{let o=i[h];i[h]=i[a],i[a]=o};return(i=>{r=i.length;let h=Math.floor(r/2);for(let a=h;a>=0;a-=1)t(i,a);for(let a=i.length-1;a>0;a--)e(i,0,a),r--,t(i,0);return i})(n.slice())},I={QuickSort:v,MergeSort:b,InsertionSort:q,BubbleSort:T,RadixSort:D,HeapSort:F};var m,c,B=class{constructor(r,t){O(this,m,-1);O(this,c,void 0);A(this,"serialize",JSON.stringify);A(this,"clonedeep",r=>JSON.parse(JSON.stringify(r)));if(!Array.isArray(r))throw new Error("parameter is not Array");this.initConfig(t),x(this,c,r),this.arr=r.slice()}initConfig(r){!r||(r.serialize&&(this.serialize=r.serialize),r.clonedeep&&(this.clonedeep=r.clonedeep))}get value(){return this.arr}get length(){return this.arr.length}get lastElement(){return this.arr[this.arr.length-1]}concat(...r){return this.arr=this.arr.concat(...r),this}copyWithin(r,t,e){return this.arr=this.arr.copyWithin(r,t,e),this}entries(){return this.arr.entries()}every(r,t){return this.arr.every(r,t)}fill(r,t,e){return this.arr=this.arr.fill(r,t,e),this}filter(r,t){return this.arr=this.arr.filter(r,t),this}find(r,t){return this.arr.find(r,t)}findIndex(r,t){return this.arr=this.arr.findIndex(r,t),this}flat(r=1){return this.arr=this.arr.flat(r),this}flatMap(r,t){return this.arr=this.arr.flatMap(r,t),this}forEach(r,t){return this.arr=this.arr.forEach(r,t),this}includes(r,t){return this.arr=this.arr.includes(r,t),this}indexOf(r,t){return this.arr=this.arr.indexOf(r,t),this}join(r){return this.arr=this.arr.join(r),this}keys(){return this.arr.keys()}lastIndexOf(r,t){return this.arr=this.arr.lastIndexOf(r,t),this}map(r,t){return this.arr=this.arr.map(r,t),this}push(...r){return this.arr=this.arr.push(...r),this}reduce(r,t){return this.arr=this.arr.reduce(r,t),this}reduceRight(r,t){return this.arr=this.arr.reduceRight(r,t),this}shift(){return this.arr=this.arr.shift(),this}slice(r,t){return this.arr=this.arr.slice(r,t),this}some(r,t){return this.arr=this.arr.some(r,t),this}splice(r,t,...e){return this.arr=this.arr.splice(r,t,...e),this}toLocaleString(){return this.arr=this.arr.toLocaleString(),this}toString(){return this.arr=this.arr.toString(),this}unshift(...r){return this.arr=this.arr.unshift(...r),this}values(){return this.arr.values()}hasOwnProperty(r){return this.arr.hasOwnProperty(r)}isPrototypeOf(r){return this.arr.isPrototypeOf(r)}propertyIsEnumerable(r){return this.arr.propertyIsEnumerable(r)}count(r){let t=0;return r===null?this.arr.forEach(e=>{e===null&&(t+=1)}):y(r)?this.arr.forEach(e=>{y(e)&&(t+=1)}):typeof r=="number"||typeof r=="string"?this.arr.forEach(e=>{e===r&&(t+=1)}):this.arr.forEach(e=>{this.serialize(r)===this.serialize(e)&&(t+=1)}),t}chunk(r){if(r<0||!r)throw new Error("size should be defined as a positive value");let t=[],e=Math.ceil(this.arr.length/r);for(let s=0;s<e;s++)t.push(this.arr.slice(s*r,s*r+r));return this.arr=t,this}clear(){return p(this,c).splice(0),this.arr.splice(0),this}mutate(){return this.arr=p(this,c),this}column(r,t){if(typeof r=="function")return this.arr=this.arr.map(r),this;if(!!t&&typeof t=="string"){let e=t.split(".");return this.arr=this.arr.map(s=>e.reduce((i,h)=>i[h],s[r])),this}if(t)throw new Error("key has to be of type 'string'");return this.arr=this.arr.map(e=>e[r]),this}isEmpty(){return this.arr.length===0}isUnique(){if(this.arr.length!==[...new Set(this.arr)].length)return!1;let r=this.arr.map(t=>typeof t=="object"&&t!==null?this.serialize(t):t);return r.length===[...new Set(r)].length}isEqual(r){return this.serialize(this.arr)===this.serialize(r)}has(r){return d(r)||y(r)?new Set(this.arr).has(r):this.arr.map(t=>this.serialize(t)).includes(this.serialize(r))}hasDuplicates(){return!this.isUnique()}hasArray(){return this.arr.some(r=>Array.isArray(r))}hasObject(){return this.arr.some(E)}hasEmptyArr(){return this.arr.some(r=>Array.isArray(r)&&r.length===0)}hasEmptyObj(){return this.arr.some(r=>E(r)&&Object.keys(r).length===0)}hasNull(){return new Set(this.arr).has(null)}hasUndefined(){return new Set(this.arr).has(void 0)}hasNullish(){let r=new Set(this.arr);return r.has(null)||r.has(void 0)}hasNaN(){return new Set(this.arr).has(NaN)}hasTrue(){return new Set(this.arr).has(!0)}hasFalse(){return new Set(this.arr).has(!1)}hasBoolean(){let r=new Set(this.arr);return r.has(!1)||r.has(!0)}hasAll(r=[]){let t=new Set(this.arr);return r.every(e=>t.has(e))}hasAllTypes(r=[],t){let e=new Set(t);return r.every(s=>e.has(typeof s))}hasNumber(){return this.arr.some(r=>typeof r=="number"&&!isNaN(r))}hasString(){return this.arr.some(r=>typeof r=="string")}hasTruthy(){return this.arr.some(r=>!!r)}hasFalsy(){return this.arr.some(r=>!r)}row(r){return this.arr=this.arr[r],this}at(r){return this.arr=r>=0?this.arr[r]:this.arr[this.arr.length+r],this}findDuplicates(){let r=this.arr.slice().sort(),t=[];for(let e=0;e<r.length-1;e++)r[e+1]==r[e]&&t.push(r[e]);return this.arr=[...new Set(t)],this}findAllOccurences(r,t=e=>e){let e=[];if(y(r)||!d(r)){let i=this.serialize(r);this.arr.map(t).forEach((h,a)=>{this.serialize(h)===i&&e.push(a)})}else this.arr.map(t).forEach((i,h)=>{i===r&&e.push(h)});return this.arr=e,this}getTruthyValues(){return this.arr=this.arr.filter(r=>!!r),this}getFalsyValues(){return this.arr=this.arr.filter(r=>!r),this}getAllKeys(){return this.arr=Object.keys(this.arr),this}random(){return this.arr[Math.floor(Math.random()*this.arr.length)]}rotate(r=0,t="clockwise"){if(r<=0)return this.arr;let e=r%this.arr.length;if(t==="clockwise")return this.arr=this.arr.slice(-1*e).concat(this.arr.slice(0,-1*e)),this;if(t==="counterclockwise")return this.arr=this.arr.slice(e).concat(this.arr.slice(0,e)),this;throw new Error('"direction" prop can only be either "clockwise" or "counterclockwise". The value you have provided is not valid.')}xsplice(r,t=0,...e){let s=this.arr.slice();return s.splice(r,t,...e),this.arr=s,this}xpop(){return this.arr.pop(),this}xpush(...r){return this.arr.push(...r),this}xshift(){return this.arr.shift(),this}xunshift(...r){return this.arr.unshift(...r),this}shuffle(){let r=this.arr.length-1,t,e,s;for(s=r;s>0;s--)t=Math.floor(Math.random()*(s+1)),e=this.arr[s],this.arr[s]=this.arr[t],this.arr[t]=e;return this}take(r,t=0){return this.arr=this.arr.slice(t,t+r),this}max(...r){return r?Math.max(...this.arr,...r.flat(1/0)):Math.max(...this.arr)}min(...r){return r?Math.min(...this.arr,...r.flat(1/0)):Math.min(...this.arr)}maxOf(r){if(typeof r=="function")return Math.max(...this.arr.map(r));if(typeof r=="string"){let t=r.split(".");if(t.length===1)return Math.max(...this.arr.map(s=>s[t[0]]));let e=this.arr.map(s=>t.reduce((i,h)=>i[h],s));return Math.max(...e)}f()}minOf(r){if(typeof r=="function")return Math.min(...this.arr.map(r));if(typeof r=="string"){let t=r.split(".");if(t.length===1)return Math.min(...this.arr.map(s=>s[t[0]]));let e=this.arr.map(s=>t.reduce((i,h)=>i[h],s));return Math.min(...e)}f()}maxBy(r){if(typeof r=="function"){let t=Math.max(...this.arr.map(r));return this.arr.find(e=>r(e)===t)}if(typeof r=="string"){let t=r.split(".");if(t.length===1){let i=Math.max(...this.arr.map(h=>h[t[0]]));return this.arr.find(h=>h[t[0]]===i)}let e=this.arr.map(i=>t.reduce((h,a)=>h[a],i)),s=Math.max(...e);return this.arr.find((i,h)=>e[h]===s)}f()}minBy(r){if(typeof r=="function"){let t=Math.min(...this.arr.map(r));return this.arr.find(e=>r(e)===t)}if(typeof r=="string"){let t=r.split(".");if(t.length===1){let i=Math.min(...this.arr.map(h=>h[t[0]]));return this.arr.find(h=>h[t[0]]===i)}let e=this.arr.map(i=>t.reduce((h,a)=>h[a],i)),s=Math.min(...e);return this.arr.find((i,h)=>e[h]===s)}f()}sum(){return this.arr.reduce((r,t)=>r+t,0)}sumOf(r){let t=0;if(typeof r=="function"){for(let e of this.arr)t+=r(e);return t}if(typeof r=="string"){let e=r.split(".");for(let s of this.arr){let i=s[e[0]];for(let h=1;h<e.length;h++)i=i[e[h]];t+=i}return t}f()}mean(){return this.arr.reduce((r,t)=>r+t,0)/this.arr.length}meanOf(r){return this.sumOf(r)/this.arr.length}product(){return this.arr.reduce((r,t)=>r*t,1)}productOf(r){let t=1;if(typeof r=="function"){for(let e of this.arr)t*=r(e);return t}if(typeof r=="string"){let e=r.split(".");for(let s of this.arr){let i=s[e[0]];for(let h=1;h<e.length;h++)i=i[e[h]];t*=i}return t}f()}union(...r){return this.arr=[...new Set([...this.arr,...r.flat(1/0)])],this}intersection(...r){[this.arr,...r].reduce((t,e)=>{let s=new Set(e);return this.arr=t.filter(i=>s.has(i)),this})}difference(r){let t=new Set(r);return this.arr=this.arr.filter(e=>!t.has(e)),this}symmetricDifference(r){let t=new Set(this.arr),e=new Set(r),s=[...t].filter(h=>!e.has(h)),i=[...e].filter(h=>!t.has(h));return this.arr=s.concat(i),this}unique(){return this.arr=[...new Set(this.arr)],this}uniqueBy(r){let t=[];if(typeof r=="function"&&(t=this.arr.map(r)),typeof r=="string"){let o=r.split(".");t=this.arr.map(l=>o.reduce((w,u)=>w[u],l))}typeof r!="function"&&typeof r!="string"&&f();let e=t.slice().sort(),s=[];for(let o=0;o<e.length-1;o++)e[o+1]==e[o]&&s.push(e[o]);let i=new Set(s),h=t.map((o,l)=>i.has(o)?void 0:l),a=new Set(h);return a.delete(void 0),this.arr=[...a].map(o=>this.arr[o]),this}deepCopy(){return this.arr=this.clonedeep(this.arr),this}types(){return this.arr=[...new Set(this.arr.map(r=>typeof r))],this}isSingle(){return this.arr.length===1}dotProduct(r){if(this.arr.length!==r.length)throw new Error("arrays must be of the same length to produce dot product.");let t=0;for(let e=0;e<this.arr.length;e++)t+=this.arr[e]*r[e];return t}crossProduct(r){if(this.arr.length!==r.length)throw new Error("arrays must be of the same length to produce cross product.");if(this.arr.length<=1)return 0;if(this.arr.length===2)return[this.arr[0]*r[1]-this.arr[1]*r[0]];if(this.arr.length===3)return[this.arr[1]*r[2]-this.arr[2]*r[1],this.arr[2]*r[0]-this.arr[0]*r[2],this.arr[0]*r[1]-this.arr[1]*r[0]];throw new Error("minimum allowed array length is 3.")}range(r,t){return r!==void 0&&t===void 0?(this.arr=Array(r+1).fill().map((e,s)=>s),this):(this.arr=Array(t-r+1).fill().map((e,s)=>r+s),this)}readOnly(){return this.arr=j(this.arr),this.arr}swapByIndexes(r,t){return[this.arr[r],this.arr[t]]=[this.arr[t],this.arr[r]],this}swapByValues(r,t){let e=this.arr,s=r,i=t;(!d(r)||!d(t))&&(e=this.arr.map(o=>this.serialize(o)),s=this.serialize(s),i=this.serialize(i));let h=e.findIndex(o=>o===s),a=e.findIndex(o=>o===i);if(!(h>-1&&a>-1))throw new Error("value is not present in the array.");return[this.arr[h],this.arr[a]]=[this.arr[a],this.arr[h]],this}deleteByIndexes(...r){let t=new Set([...r]);return this.arr=this.arr.filter((e,s)=>!t.has(s)),this}deleteByValues(...r){let t=[...r].map(s=>this.serialize(s)),e=new Set([...t]);return this.arr=this.arr.filter(s=>!e.has(this.serialize(s))),this}clearByIndexes(...r){return[...r].forEach(t=>{this.arr[t]!==void 0&&(this.arr[t]=void 0)}),this}clearByValues(...r){let t=[...r].map(s=>this.serialize(s)),e=new Set([...t]);return this.arr=this.arr.map(s=>e.has(this.serialize(s))?void 0:s),this}replaceByIndex(r,t){return this.arr.splice(r,1,t),this}replaceByIndexes(r=[],t=[]){return r.forEach(e=>{this.arr[e]=t[e]}),this}replaceByValue(r,t,e=!0){let s=this.arr.slice(),i=e?this.findAllOccurences(r):{value:[this.arr.indexOf(r)]};return i.value[0]>-1&&i.value.forEach(h=>{s[h]=t}),this.arr=s,this}replaceByValues(r=[],t=[]){if(r.length!==t.length)throw new Error("can't replace values because the arrays that you have provided are not of equal size.");return r.forEach((e,s)=>{this.replaceByValue(e,t[s])}),this}toJSONObject(r=[],t=[]){if(r.length+t.length===0)return JSON.parse(JSON.stringify(N({},this.arr)));if(!Array.isArray(r)||!Array.isArray(t))throw new Error("'keys' and 'values' must be arrays.");if(r.length!==t.length)throw new Error("array length of 'keys' and 'values' must be the same.");let e={},s=JSON.parse(JSON.stringify(r)),i=JSON.parse(JSON.stringify(t));if(s.length!==i.length)throw new Error("objects' inner values must be of primitive types.");return s.forEach((h,a)=>{e[h]=i[a]}),e}reverse(){let r=this.arr.length,t=Math.floor(r/2);for(let e=0;e<t;e++)[this.arr[e],this.arr[r-1-e]]=[this.arr[r-1-e],this.arr[e]];return this}OR(r,t){if(!Array.isArray(r)&&t===void 0)return this.arr.includes(r);if(!Array.isArray(r)&&t!==void 0)return this.arr.some(e=>t(e,r));if(Array.isArray(r)&&t===void 0)return g(r,this.arr),this.arr.some((e,s)=>e===r[s]);if(Array.isArray(r)&&t!==void 0)return g(r,this.arr),this.arr.some((e,s)=>t(e,r[s]))}AND(r,t){if(!Array.isArray(r)&&t===void 0)return this.arr.every(e=>e===r);if(!Array.isArray(r)&&t!==void 0)return this.arr.every(e=>t(e,r));if(Array.isArray(r)&&t===void 0)return g(r,this.arr),this.arr.every((e,s)=>e===r[s]);if(Array.isArray(r)&&t!==void 0)return g(r,this.arr),this.arr.every((e,s)=>t(e,r[s]))}OR_ALL(r=!1){return!!r||this.arr.some(t=>!!t)}AND_ALL(r=!0){return!!r&&this.arr.every(t=>!!t)}OR_AND(r=!0){return this.arr.every(t=>!!t||!!r)}AND_OR(r=!0){return this.arr.some(t=>!!t&&!!r)}XOR_ALL(r=!1){return!!this.arr.map(t=>!!t).reduce((t,e)=>t^e,!1)^!!r}interpolate(r){if(this.arr.length!==3)throw new Error('left array length must be 3, representing the "starting", "middle" & "final" values respectively.');if(r.length!==3||![void 0,null,!1,"x","X","?"].includes(r[1]))throw new Error("right array length must be 3, representing the [$starting_value, undefined, $final_value].");let[t,e,s]=this.arr,[i,,h]=r;return h-(h-i)*(s-e)/(s-t)}sort({order:r="ascending",sortType:t="QuickSort",sortBy:e}={}){let s,i;if(e!==void 0&&typeof e!="function")throw new Error('"sortBy" has to be a function.');e?(s=e,i=!0):s=u=>u;let h=[...new Set(this.arr.map(u=>typeof s(u)))];if(h.length>1)throw new Error("cannot sort items of different types.");if(h[0]!=="number"&&h[0]!=="string")throw new Error("cannot sort items of complex types. sorting is only possible on numbers or strings.");let a={},o=this.arr.slice(),l=this.arr.map(s);l.forEach((u,k)=>{a[u]=o[k]}),this.arr=I[t](l),r==="descending"&&this.reverse();let w=[];return i&&(this.arr.map(u=>{w.push(a[u])}),this.arr=w),this}zip(...r){return this.arr=this.arr.map((t,e)=>r.reduce((s,i)=>[...s,i[e]],[t])),this}unzip(){return this.arr=this.zip(this.arr).value,this}next(){return x(this,m,p(this,m)+1),this.arr[p(this,m)]}};m=new WeakMap,c=new WeakMap;var C=(n,r)=>new B(n,r),Z=C;export{Z as default};
//# sourceMappingURL=index.js.map
